def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
class Stack:
    def __init__(self):
        self.items = []
        
    def push(self, item):
        self.items.append(item)
        
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
            
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
            
    def is_empty(self):
        return len(self.items) == 0
        
    def size(self):
        return len(self.items)
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True
def reverse_string(s):
    return s[::-1]
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
import numpy as np

def calculate_mean(numbers):
    return np.mean(numbers)

def calculate_stddev(numbers):
    return np.std(numbers)
class Queue:
    def __init__(self):
        self.items = []
        
    def enqueue(self, item):
        self.items.insert(0, item)
        
    def dequeue(self):
        if not self.is_empty():
            return self.items.pop()
            
    def is_empty(self):
        return len(self.items) == 0
        
    def size(self):
        return len(self.items)
def fibonacci_sequence(n):
    sequence = [0, 1]
    while len(sequence) < n:
        next_num = sequence[-1] + sequence[-2]
        sequence.append(next_num)
    return sequence
def celsius_to_fahrenheit(celsius):
    return (celsius * 9/5) + 32
import numpy as np
import tensorflow as tf
for i in range(10):
    print(i)
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
x = 5
if x > 0:
    print("Positive")
elif x < 0:
    print("Negative")
else:
    print("Zero")
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
p1 = Person("Alice", 25)
print(p1.name, p1.age)
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True
def fibonacci_sequence(n):
    sequence = [0, 1]
    while len(sequence) < n:
        next_num = sequence[-1] + sequence[-2]
        sequence.append(next_num)
    return sequence
def calculate_average(numbers):
    total = sum(numbers)
    average = total / len(numbers)
    return average
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, LSTM, Dense

def load_codes(file_path='code_storage.txt'):
    with open(file_path, 'r') as f:
        codes = f.read().splitlines()
    return codes

def encode_sequence(sequence, char_to_index):
    encoded_sequence = [char_to_index[char] for char in sequence]
    return encoded_sequence

def generate_model(input_shape, num_classes):
    model = Sequential([
        Embedding(input_dim=num_classes, output_dim=256, input_length=input_shape[1]),  # Increased embedding output_dim to capture more information
        LSTM(528, return_sequences=True),  # Increased LSTM units for better learning capacity
        Dense(num_classes, activation='softmax')
    ])
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['categorical_accuracy'])
    return model

def generate_random_code(model, index_to_char, num_classes, max_sequence_length):
    seed = np.random.randint(num_classes, size=(1, max_sequence_length))
    generated_sequence = model.predict(seed).argmax(axis=-1)
    generated_code = ''.join(index_to_char[idx] for idx in generated_sequence[0])
    return generated_code

def main():
    codes = load_codes()
    unique_chars = sorted(set(''.join(codes)))
    char_to_index = {char: index for index, char in enumerate(unique_chars)}
    index_to_char = {index: char for char, index in char_to_index.items()}

    num_examples = len(codes)
    training_codes = codes[:int(0.8 * num_examples)]
    validation_codes = codes[int(0.8 * num_examples):]

    max_sequence_length = max(len(code) for code in codes)
    num_classes = len(unique_chars)

    training_input = [encode_sequence(code, char_to_index) for code in training_codes]
    validation_input = [encode_sequence(code, char_to_index) for code in validation_codes]

    # Padding using dtype=np.int32 for compatibility with TensorFlow 2.7+
    training_input = tf.keras.preprocessing.sequence.pad_sequences(training_input, maxlen=max_sequence_length, padding='post', dtype=np.int32)
    validation_input = tf.keras.preprocessing.sequence.pad_sequences(validation_input, maxlen=max_sequence_length, padding='post', dtype=np.int32)

    training_output = tf.keras.utils.to_categorical(training_input, num_classes=num_classes)
    validation_output = tf.keras.utils.to_categorical(validation_input, num_classes=num_classes)

    model = generate_model(training_input.shape, num_classes)
    
    # Experiment with hyperparameters like batch size, epochs, and learning rate for better results
    model.fit(training_input, training_output, validation_data=(validation_input, validation_output), epochs=100, batch_size=128)

    generated_code = generate_random_code(model, index_to_char, num_classes, max_sequence_length)
    print("Generated Code:")
    print(generated_code)

if __name__ == "__main__":
    main()
import time
import pyautogui
from PIL import Image

# Função para localizar a posição de uma imagem na tela
def encontrar_imagem(template):
    screen = pyautogui.screenshot()
    img = Image.open(template)
    position = pyautogui.locate(img, screen)
    if position:
        return position.left, position.top
    return None

# Função para clicar em um botão usando sua imagem
def clicar_botao(template):
    position = encontrar_imagem(template)
    if position:
        x, y = position
        pyautogui.click(x, y)
        return True
    return False

# Função para enviar uma mensagem no chat pressionando Enter
def enviar_mensagem_teclado(mensagem):
    # Esperar um pouco para garantir que o chat esteja aberto e pronto para receber a mensagem
    time.sleep(2)

    # Digitar a mensagem e pressionar Enter
    pyautogui.typewrite(mensagem)
    pyautogui.press("enter")

# Exemplo de uso da função para clicar no botão "Sim"
if clicar_botao("botao_sim.png"):
    print("Botão 'Sim' clicado!")
else:
    print("Botão 'Sim' não encontrado.")

# Espera um pouco para simular ações do jogador (opcional)
time.sleep(2)

# Exemplo de uso da função para clicar no botão "Aceitar"
if clicar_botao("botao_aceitar.png"):
    print("Botão 'Aceitar' clicado!")
else:
    print("Botão 'Aceitar' não encontrado.")

# Enviar uma mensagem
mensagem_para_enviar = "pls any item or money ? only need a set t4 to back to game i have a mount"
enviar_mensagem_teclado(mensagem_para_enviar)
